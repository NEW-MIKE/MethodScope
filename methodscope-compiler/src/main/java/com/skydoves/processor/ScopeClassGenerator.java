/*
 * Copyright (C) 2017 skydoves
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.skydoves.processor;

import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.VariableElement;

@SuppressWarnings("ALL")
public class ScopeClassGenerator {

    private final MethodScopeAnnotatedClass annotatedClazz;
    private final String packageName;
    private final AnnotationMirror scopeAnnotation;
    private final String scopeName;

    private static final String SCOPE_PREFIX = "Scope";
    private final String INITIALIZE_IMPL = "initializeScopes";
    private static final String SCOPE_INITIALIZE = "Init";

    private static final String VALUE_SCOPES = "scopes";
    private static final String VALUE_VALUES = "values";

    public ScopeClassGenerator(String packageName, MethodScopeAnnotatedClass annotatedClazz, AnnotationMirror scopeAnnotation) {
        this.packageName = packageName;
        this.annotatedClazz = annotatedClazz;
        this.scopeAnnotation = scopeAnnotation;
        this.scopeName = scopeAnnotation.getAnnotationType().asElement().getSimpleName().toString();
    }

    public TypeSpec generate() {
        TypeSpec.Builder builder = TypeSpec.classBuilder(getScopeClassName())
                .addJavadoc("Generated by MethodScope. (https://github.com/skydoves/MethodScope).\n")
                .addModifiers(Modifier.PUBLIC)
                .addMethods(getScopedMethodScopes())
                .superclass(TypeName.get(annotatedClazz.annotatedElement.asType()));

        return builder.build();
    }

    private List<MethodSpec> getScopedMethodScopes() {
        List<MethodSpec> methodSpecList = new ArrayList<>();

        //TODO should be fixed the second filter
        annotatedClazz.annotatedElement.getEnclosedElements().stream()
                .filter(element -> element instanceof ExecutableElement)
                .map(element -> (ExecutableElement) element)
                .forEach(method -> {
                    annotatedClazz.annotatedElement.getEnclosedElements().stream()
                          .filter(element -> element instanceof ExecutableElement)
                          .map(element -> (ExecutableElement) element)
                          .filter(element -> element.getSimpleName().toString().equals(getScopeMethodname(element)))
                          .forEach(scopeMethod -> {
                              MethodSpec methodSpec = MethodSpec
                                    .methodBuilder(method.getSimpleName().toString())
                                    .addAnnotation(Override.class)
                                    .addStatement("super.$N()", scopeMethod.getSimpleName().toString())
                                    .build();
                              methodSpecList.add(methodSpec);
                          });
                });

        return methodSpecList;
    }

    private Modifier[] getVariableModifier(VariableElement variableElement) {
        List<Modifier> modifiers = new ArrayList<>();

        Iterator iterator = variableElement.getModifiers().iterator();
        while (iterator.hasNext()) {
            modifiers.add((Modifier) iterator.next());
        }
        return modifiers.toArray(new Modifier[modifiers.size()]);
    }

    private String getScopeClassName() {
        return this.annotatedClazz.clazzName + "_" + getScopeName();
    }

    private String getScopeMethodname(ExecutableElement method) {
        return getScopeName() + "_" + method.getSimpleName().toString();
    }

    private String getScopeName() {
        return this.scopeName;
    }
}
