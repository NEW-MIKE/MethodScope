/*
 * Copyright (C) 2019 skydoves
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.skydoves.processor;

import com.google.common.base.VerifyException;
import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import java.util.ArrayList;
import java.util.List;
import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;

@SuppressWarnings({"FieldCanBeLocal", "WeakerAccess"})
public class ScopeClassGenerator {

  private final MethodScopeAnnotatedClass annotatedClazz;
  private final String packageName;
  private final AnnotationMirror scopeAnnotation;
  private final String scopeName;
  private boolean abstractFlag = false;

  public ScopeClassGenerator(
      String packageName,
      MethodScopeAnnotatedClass annotatedClazz,
      AnnotationMirror scopeAnnotation) {
    this.packageName = packageName;
    this.annotatedClazz = annotatedClazz;
    this.scopeAnnotation = scopeAnnotation;
    this.scopeName = scopeAnnotation.getAnnotationType().asElement().getSimpleName().toString();
  }

  public TypeSpec generate() {
    TypeSpec.Builder builder =
        TypeSpec.classBuilder(getScopeClassName())
            .addJavadoc("Generated by MethodScope. (https://github.com/skydoves/MethodScope).\n")
            .addModifiers(Modifier.PUBLIC)
            .addAnnotations(getAnnotations())
            .addMethods(getScopedMethodScopes())
            .addMethods(getAbstractScopedMethodScopes())
            .superclass(TypeName.get(annotatedClazz.annotatedElement.asType()));

    return builder.build();
  }

  private List<AnnotationSpec> getAnnotations() throws IllegalArgumentException {
    List<AnnotationSpec> annotationSpecs = new ArrayList<>();
    scopeAnnotation
        .getElementValues()
        .entrySet()
        .forEach(
            entry -> {
              if (entry.getValue() instanceof AnnotationMirror) {
                AnnotationSpec annotationSpec =
                    AnnotationSpec.get((AnnotationMirror) entry.getValue());
                annotationSpecs.add(annotationSpec);
              }
            });

    return annotationSpecs;
  }

  private List<MethodSpec> getScopedMethodScopes() throws VerifyException {
    List<MethodSpec> methodSpecList = new ArrayList<>();
    annotatedClazz
        .annotatedElement
        .getEnclosedElements()
        .stream()
        .filter(
            element ->
                !element.getModifiers().contains(Modifier.ABSTRACT)
                    && !element.getModifiers().contains(Modifier.FINAL)
                    && element.getModifiers().contains(Modifier.PUBLIC))
        .filter(element -> element instanceof ExecutableElement)
        .map(element -> (ExecutableElement) element)
        .forEach(
            method ->
                annotatedClazz
                    .annotatedElement
                    .getEnclosedElements()
                    .stream()
                    .filter(element -> element instanceof ExecutableElement)
                    .filter(
                        element ->
                            element.getSimpleName().toString().equals(getScopeMethodName(method))
                                || (hasScopedAnnotation(element)
                                    & element
                                        .getSimpleName()
                                        .toString()
                                        .startsWith(method.getSimpleName().toString())))
                    .filter(element -> !method.getSimpleName().toString().contains("<init>"))
                    .map(element -> (ExecutableElement) element)
                    .forEach(
                        scopeMethod -> {
                          MethodSpec methodSpec =
                              MethodSpec.methodBuilder(method.getSimpleName().toString())
                                  .addAnnotation(Override.class)
                                  .addModifiers(Modifier.PUBLIC)
                                  .addStatement("super.$N()", method.getSimpleName().toString())
                                  .addStatement(
                                      "super.$N()", scopeMethod.getSimpleName().toString())
                                  .build();
                          methodSpecList.add(methodSpec);
                        }));

    return methodSpecList;
  }

  private List<MethodSpec> getAbstractScopedMethodScopes() throws VerifyException {
    List<MethodSpec> methodSpecList = new ArrayList<>();
    annotatedClazz
        .annotatedElement
        .getEnclosedElements()
        .stream()
        .filter(element -> element.getModifiers().contains(Modifier.ABSTRACT))
        .filter(element -> element instanceof ExecutableElement)
        .map(element -> (ExecutableElement) element)
        .forEach(
            method -> {
              this.abstractFlag = false;
              annotatedClazz
                  .annotatedElement
                  .getEnclosedElements()
                  .stream()
                  .filter(element -> element instanceof ExecutableElement)
                  .filter(
                      element ->
                          element.getSimpleName().toString().equals(getScopeMethodName(method))
                              || (hasScopedAnnotation(element)
                                  & element
                                      .getSimpleName()
                                      .toString()
                                      .startsWith(method.getSimpleName().toString())))
                  .filter(element -> !method.getSimpleName().toString().contains("<init>"))
                  .map(element -> (ExecutableElement) element)
                  .forEach(
                      scopeMethod -> {
                        abstractFlag = true;
                        MethodSpec methodSpec =
                            MethodSpec.methodBuilder(method.getSimpleName().toString())
                                .addAnnotation(Override.class)
                                .addModifiers(Modifier.PUBLIC)
                                .addStatement("super.$N()", scopeMethod.getSimpleName().toString())
                                .build();
                        methodSpecList.add(methodSpec);
                      });

              if (!abstractFlag) {
                throw new VerifyException(
                    String.format(
                        "`%s` method is an abstract method. Should be implemented `%s` method.",
                        method.getSimpleName().toString(), getScopeMethodName(method)));
              }
            });

    return methodSpecList;
  }

  private boolean hasScopedAnnotation(Element element) {
    return element
        .getAnnotationMirrors()
        .stream()
        .anyMatch(
            annotation ->
                annotation.toString().contains("@com.skydoves.methodscope.Scoped(")
                    && annotation.toString().contains(getScopeName()));
  }

  private String getScopeClassName() {
    return this.annotatedClazz.clazzName + "_" + getScopeName();
  }

  private String getScopeMethodName(ExecutableElement method) {
    return method.getSimpleName().toString() + getScopeName();
  }

  private String getScopeName() {
    return this.scopeName;
  }
}
