/*
 * Copyright (C) 2019 skydoves
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.skydoves.processor;

import com.google.common.base.VerifyException;
import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

import java.util.ArrayList;
import java.util.List;

import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.VariableElement;

@SuppressWarnings({"FieldCanBeLocal", "WeakerAccess", "ConstantConditions"})
public class ScopeClassGenerator {

  private final MethodScopeAnnotatedClass annotatedClazz;
  private final String packageName;
  private final AnnotationMirror scopeAnnotation;
  private final String scopeName;
  private boolean abstractFlag = false;

  public ScopeClassGenerator(
      String packageName,
      MethodScopeAnnotatedClass annotatedClazz,
      AnnotationMirror scopeAnnotation) {
    this.packageName = packageName;
    this.annotatedClazz = annotatedClazz;
    this.scopeAnnotation = scopeAnnotation;
    this.scopeName = scopeAnnotation.getAnnotationType().asElement().getSimpleName().toString();
  }

  public TypeSpec generate() {
    TypeSpec.Builder builder =
        TypeSpec.classBuilder(getScopeClassName())
            .addJavadoc("Generated by MethodScope. (https://github.com/skydoves/MethodScope).\n")
            .addModifiers(Modifier.PUBLIC)
            .addAnnotations(getAnnotations())
            .addFields(getScopedFields())
            .addMethods(getScopedMethodScopes())
            .addMethods(getAbstractScopedMethodScopes())
            .superclass(TypeName.get(annotatedClazz.annotatedElement.asType()));

    return builder.build();
  }

  private List<AnnotationSpec> getAnnotations() throws IllegalArgumentException {
    List<AnnotationSpec> annotationSpecs = new ArrayList<>();
    scopeAnnotation
        .getElementValues()
        .entrySet()
        .forEach(
            entry -> {
              if (entry.getValue() instanceof AnnotationMirror) {
                AnnotationSpec annotationSpec =
                    AnnotationSpec.get((AnnotationMirror) entry.getValue());
                annotationSpecs.add(annotationSpec);
              }
            });

    return annotationSpecs;
  }

  private List<FieldSpec> getScopedFields() throws VerifyException {
    List<FieldSpec> fieldSpecs = new ArrayList<>();
    annotatedClazz
        .annotatedElement
        .getEnclosedElements()
        .stream()
        .filter(variable -> variable instanceof VariableElement)
        .map(variable -> (VariableElement) variable)
        .filter(this::hasScopedAnnotation)
        .forEach(variable -> {
          FieldSpec.Builder builder =
              FieldSpec.builder(TypeName.get(variable.asType()), variable.getSimpleName().toString());
          variable.getModifiers().forEach(builder::addModifiers);
          variable.getAnnotationMirrors().forEach(annotation ->
            builder.addAnnotation(AnnotationSpec.get(annotation)));
          fieldSpecs.add(builder.build());
        });
    return fieldSpecs;
  }

  private List<MethodSpec> getScopedMethodScopes() throws VerifyException {
    List<MethodSpec> methodSpecList = new ArrayList<>();
    annotatedClazz
        .annotatedElement
        .getEnclosedElements()
        .stream()
        .filter(
            element ->
                !element.getModifiers().contains(Modifier.ABSTRACT)
                    && !element.getModifiers().contains(Modifier.FINAL)
                    && element.getModifiers().contains(Modifier.PUBLIC))
        .filter(element -> element instanceof ExecutableElement)
        .map(element -> (ExecutableElement) element)
        .forEach(
            method ->
                annotatedClazz
                    .annotatedElement
                    .getEnclosedElements()
                    .stream()
                    .filter(element -> element instanceof ExecutableElement)
                    .map(element -> (ExecutableElement) element)
                    .filter(
                        element ->
                            !element.getModifiers().contains(Modifier.ABSTRACT)
                                && element.getModifiers().contains(Modifier.PUBLIC))
                    .filter(
                        element ->
                            element.getSimpleName().toString().equals(getScopeMethodName(method))
                                || (hasScopedAnnotation(element)
                                    & element
                                        .getSimpleName()
                                        .toString()
                                        .startsWith(method.getSimpleName().toString())))
                    .filter(
                        element ->
                            !method.getSimpleName().toString().contains("<init>")
                                && method.getReturnType().equals((element).getReturnType()))
                    .filter(element -> !compareParameters(method, element))
                    .forEach(
                        scopeMethod -> {
                          MethodSpec.Builder builder =
                              MethodSpec.methodBuilder(method.getSimpleName().toString())
                                  .addAnnotation(Override.class)
                                  .addModifiers(Modifier.PUBLIC)
                                  .addParameters(getParameterSpecs(method))
                                  .returns(TypeName.get(method.getReturnType()));

                          StringBuilder parameters = new StringBuilder();
                          method
                              .getParameters()
                              .forEach(
                                  parameter ->
                                      parameters
                                          .append(parameter.getSimpleName().toString())
                                          .append(", "));
                          parameters.replace(
                              parameters.lastIndexOf(", "), parameters.lastIndexOf(", ") + 2, "");

                          if (TypeName.get(method.getReturnType())
                              .equals(TypeName.get(Void.class))) {
                            builder.addStatement(
                                "super.$N(" + parameters.toString() + ")",
                                method.getSimpleName().toString());
                            builder.addStatement(
                                "super.$N(" + parameters.toString() + ")",
                                scopeMethod.getSimpleName().toString());
                          } else {
                            builder.addStatement(
                                "super.$N(" + parameters.toString() + ")",
                                method.getSimpleName().toString());
                            builder.addStatement(
                                "return super.$N(" + parameters.toString() + ")",
                                scopeMethod.getSimpleName().toString());
                          }
                          methodSpecList.add(builder.build());
                        }));

    return methodSpecList;
  }

  private List<MethodSpec> getAbstractScopedMethodScopes() throws VerifyException {
    List<MethodSpec> methodSpecList = new ArrayList<>();
    annotatedClazz
        .annotatedElement
        .getEnclosedElements()
        .stream()
        .filter(element -> element.getModifiers().contains(Modifier.ABSTRACT))
        .filter(element -> element instanceof ExecutableElement)
        .map(element -> (ExecutableElement) element)
        .forEach(
            method -> {
              this.abstractFlag = false;
              annotatedClazz
                  .annotatedElement
                  .getEnclosedElements()
                  .stream()
                  .filter(element -> element instanceof ExecutableElement)
                  .map(element -> (ExecutableElement) element)
                  .filter(
                      element ->
                          !element.getModifiers().contains(Modifier.ABSTRACT)
                              && element.getModifiers().contains(Modifier.PUBLIC))
                  .filter(
                      element ->
                          element.getSimpleName().toString().equals(getScopeMethodName(method))
                              || (hasScopedAnnotation(element)
                                  & element
                                      .getSimpleName()
                                      .toString()
                                      .startsWith(method.getSimpleName().toString())))
                  .filter(
                      element ->
                          !method.getSimpleName().toString().contains("<init>")
                              && method.getReturnType().equals((element).getReturnType()))
                  .filter(element -> !compareParameters(method, element))
                  .forEach(
                      scopeMethod -> {
                        abstractFlag = true;
                        MethodSpec.Builder builder =
                            MethodSpec.methodBuilder(method.getSimpleName().toString())
                                .addAnnotation(Override.class)
                                .addModifiers(Modifier.PUBLIC)
                                .addParameters(getParameterSpecs(method))
                                .returns(TypeName.get(method.getReturnType()));

                        StringBuilder parameters = new StringBuilder();
                        method
                            .getParameters()
                            .forEach(
                                parameter ->
                                    parameters
                                        .append(parameter.getSimpleName().toString())
                                        .append(", "));
                        parameters.replace(
                            parameters.lastIndexOf(", "), parameters.lastIndexOf(", ") + 2, "");

                        if (TypeName.get(method.getReturnType()).equals(TypeName.get(Void.class))) {
                          builder.addStatement(
                              "super.$N(" + parameters.toString() + ")",
                              scopeMethod.getSimpleName().toString());
                        } else {
                          builder.addStatement(
                              "return super.$N(" + parameters.toString() + ")",
                              scopeMethod.getSimpleName().toString());
                        }
                        methodSpecList.add(builder.build());
                      });

              if (!abstractFlag) {
                throw new VerifyException(
                    String.format(
                        "`%s` method is an abstract method. Should be implemented `%s` method or attached @Scoped annotation.",
                        method.getSimpleName().toString(), getScopeMethodName(method)));
              }
            });

    return methodSpecList;
  }

  private boolean hasScopedAnnotation(Element element) {
    return element
        .getAnnotationMirrors()
        .stream()
        .anyMatch(
            annotation ->
                annotation.toString().contains("@com.skydoves.methodscope.Scoped(")
                    && annotation.toString().contains(getScopeName()));
  }

  @SuppressWarnings("BooleanMethodIsAlwaysInverted")
  private boolean compareParameters(ExecutableElement element0, ExecutableElement element1) {
    if (element0.getParameters().size() != element1.getParameters().size()) return true;
    for (int i = 0; i < element0.getParameters().size(); i++) {
      if (!TypeName.get(element0.getParameters().get(0).asType())
          .equals(TypeName.get(element1.getParameters().get(0).asType()))) return true;
    }
    return false;
  }

  private List<ParameterSpec> getParameterSpecs(ExecutableElement element) {
    List<ParameterSpec> parameterSpecs = new ArrayList<>();
    element.getParameters().forEach(parameter -> parameterSpecs.add(ParameterSpec.get(parameter)));
    return parameterSpecs;
  }

  private String getScopeClassName() {
    return this.annotatedClazz.clazzName + "_" + getScopeName();
  }

  private String getScopeMethodName(ExecutableElement method) {
    return method.getSimpleName().toString() + getScopeName();
  }

  private String getScopeName() {
    return this.scopeName;
  }
}
